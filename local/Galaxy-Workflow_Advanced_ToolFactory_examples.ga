{
    "a_galaxy_workflow": "true",
    "annotation": "",
    "format-version": "0.1",
    "name": " Advanced ToolFactory example workflow",
    "steps": {
        "0": {
            "annotation": "",
            "content_id": null,
            "errors": null,
            "id": 0,
            "input_connections": {},
            "inputs": [
                {
                    "description": "",
                    "name": "Galaxy12-[blastn_Select_first_on_data_7_vs___13apr2014-htgs__].tabular"
                }
            ],
            "label": "Galaxy12-[blastn_Select_first_on_data_7_vs___13apr2014-htgs__].tabular",
            "name": "Input dataset",
            "outputs": [],
            "position": {
                "left": 0,
                "top": 0
            },
            "tool_id": null,
            "tool_state": "{\"optional\": false, \"tag\": null}",
            "tool_version": null,
            "type": "data_input",
            "uuid": "93c821e3-353c-4549-9332-0bc5896bfb4d",
            "when": null,
            "workflow_outputs": []
        },
        "1": {
            "annotation": "",
            "content_id": null,
            "errors": null,
            "id": 1,
            "input_connections": {},
            "inputs": [
                {
                    "description": "",
                    "name": "iris.xls"
                }
            ],
            "label": "iris.xls",
            "name": "Input dataset",
            "outputs": [],
            "position": {
                "left": 0,
                "top": 184.46665954589844
            },
            "tool_id": null,
            "tool_state": "{\"optional\": false, \"tag\": null}",
            "tool_version": null,
            "type": "data_input",
            "uuid": "9a76058a-3fd0-49c7-95ab-ce066b974aa1",
            "when": null,
            "workflow_outputs": []
        },
        "2": {
            "annotation": "",
            "content_id": null,
            "errors": null,
            "id": 2,
            "input_connections": {},
            "inputs": [
                {
                    "description": "",
                    "name": "dolphinpoop9000reads_sample"
                }
            ],
            "label": "dolphinpoop9000reads_sample",
            "name": "Input dataset",
            "outputs": [],
            "position": {
                "left": 280,
                "top": 0
            },
            "tool_id": null,
            "tool_state": "{\"optional\": false, \"tag\": null}",
            "tool_version": null,
            "type": "data_input",
            "uuid": "cd0b9ac6-2947-4d97-823c-ec703bf374da",
            "when": null,
            "workflow_outputs": []
        },
        "3": {
            "annotation": "",
            "content_id": null,
            "errors": null,
            "id": 3,
            "input_connections": {},
            "inputs": [
                {
                    "description": "",
                    "name": "BlastTools.jar"
                }
            ],
            "label": "BlastTools.jar",
            "name": "Input dataset",
            "outputs": [],
            "position": {
                "left": 0,
                "top": 439.9333190917969
            },
            "tool_id": null,
            "tool_state": "{\"optional\": false, \"tag\": null}",
            "tool_version": null,
            "type": "data_input",
            "uuid": "b7177d24-07eb-4ad1-ae83-0c1f239c3fc5",
            "when": null,
            "workflow_outputs": []
        },
        "4": {
            "annotation": "",
            "content_id": null,
            "errors": null,
            "id": 4,
            "input_connections": {},
            "inputs": [
                {
                    "description": "",
                    "name": "rossi.tab"
                }
            ],
            "label": "rossi.tab",
            "name": "Input dataset",
            "outputs": [],
            "position": {
                "left": 560,
                "top": 0
            },
            "tool_id": null,
            "tool_state": "{\"optional\": false, \"tag\": null}",
            "tool_version": null,
            "type": "data_input",
            "uuid": "eafa1bf9-9394-4b87-b9b2-6a475830c667",
            "when": null,
            "workflow_outputs": []
        },
        "5": {
            "annotation": "",
            "content_id": null,
            "errors": null,
            "id": 5,
            "input_connections": {},
            "inputs": [
                {
                    "description": "",
                    "name": "Galaxy51-[_blastn_21-22.tabular].tabular"
                }
            ],
            "label": "Galaxy51-[_blastn_21-22.tabular].tabular",
            "name": "Input dataset",
            "outputs": [],
            "position": {
                "left": 560,
                "top": 184.46665954589844
            },
            "tool_id": null,
            "tool_state": "{\"optional\": false, \"tag\": null}",
            "tool_version": null,
            "type": "data_input",
            "uuid": "28bfad75-9c72-4e68-9421-dd4714096daf",
            "when": null,
            "workflow_outputs": []
        },
        "6": {
            "annotation": "",
            "content_id": "toolfactory",
            "errors": null,
            "id": 6,
            "input_connections": {
                "io_param|ppass|io|history_inputs_0|input_files": {
                    "id": 1,
                    "output_name": "output"
                }
            },
            "inputs": [],
            "label": null,
            "name": "toolfactory",
            "outputs": [
                {
                    "name": "toolgen",
                    "type": "input"
                },
                {
                    "name": "untested_tool",
                    "type": "tgz"
                }
            ],
            "position": {
                "left": 280,
                "top": 184.46665954589844
            },
            "post_job_actions": {},
            "tool_id": "toolfactory",
            "tool_state": "{\"__input_ext\": \"input\", \"__workflow_invocation_uuid__\": \"2b5a9547917c11ee9703a7832fba00cb\", \"chromInfo\": \"/evol/galaxytf231/tool-data/shared/ucsc/chrom/?.len\", \"citations\": [], \"cl_options\": {\"cl_prefix\": \"\", \"cl_suffix\": \"\", \"cl_override\": \"\", \"test_override\": \"\", \"xtracond\": {\"needxtra\": \"no\", \"__current_case__\": 0, \"xtra_files\": \"\"}}, \"deps\": {\"packages\": \"pandas=1.5.3, plotly=5.9.0, python-kaleido=0.2.1\", \"usescript\": {\"choosescript\": \"yes\", \"__current_case__\": 1, \"scriptrunner\": \"python\", \"dynScript\": \"\\nimport argparse\\nimport shutil\\nimport sys\\nimport math\\nimport plotly.express as px\\nimport pandas as pd\\n# Ross Lazarus July 2023\\n# based on various plotly tutorials\\nMAXHTMLROWS = 5000 # empirically, browsers die at 10k so stop here for safety and give png\\nparser = argparse.ArgumentParser()\\na = parser.add_argument\\na('--input_tab',default='')\\na('--header',default='')\\na('--htmlout',default=\\\"test_run.html\\\")\\na('--xcol',default='')\\na('--ycol',default='')\\na('--colourcol',default='')\\na('--hovercol',default='')\\na('--title',default='Default plot title')\\na('--image_type',default='short_html')\\nargs = parser.parse_args()\\nisColour = False\\nisHover = False\\nif len(args.colourcol.strip()) > 0:\\n    isColour = True\\nif len(args.hovercol.strip()) > 0:\\n    isHover = True\\ndf = pd.read_csv(args.input_tab, sep='\\\\t')\\nMAXLEN=35\\nNCOLS = df.columns.size\\nNROWS = len(df.index)\\ndefaultcols = ['col%d' % (x+1) for x in range(NCOLS)]\\ntestcols = df.columns\\nif args.image_type in ['short_html', 'long_html']: # refuse to create browser crashing gob stopper html\\n    if NROWS > MAXHTMLROWS:\\n        sys.stderr.write('## CRITICAL USAGE ERROR (not a bug!): As advised on the tool form, 5k+ rows (you supplied %d) in html breaks browsers, so redo the job but change to png format output.' % NROWS)\\n        sys.exit(6)\\nif len(args.header.strip()) > 0:\\n    newcols = args.header.split(',')\\n    if len(newcols) == NCOLS:\\n        if (args.xcol in newcols) and (args.ycol in newcols):\\n            df.columns = newcols\\n        else:\\n            sys.stderr.write('## CRITICAL USAGE ERROR (not a bug!): xcol %s and/or ycol %s not found in supplied header parameter %s' % (args.xcol, args.ycol, args.header))\\n            sys.exit(4)\\n    else:\\n        sys.stderr.write('## CRITICAL USAGE ERROR (not a bug!): Supplied header %s has %d comma delimited header names - does not match the input tabular file %d columns' % (args.header, len(newcols), NCOLS))\\n        sys.exit(5)\\nelse: # no header supplied - check for a real one that matches the x and y axis column names\\n    colsok = (args.xcol in testcols) and (args.ycol in testcols) # if they match, probably ok...should use more code and logic..\\n    if colsok:\\n        df.columns = testcols # use actual header\\n    else:\\n        colsok = (args.xcol in defaultcols) and (args.ycol in defaultcols)\\n        if colsok:\\n            sys.stderr.write('replacing first row of data derived header %s with %s' % (testcols, defaultcols))\\n            df.columns = defaultcols\\n        else:\\n            sys.stderr.write('## CRITICAL USAGE ERROR (not a bug!): xcol %s and ycol %s do not match anything in the file header, supplied header or automatic default column names %s' % (args.xcol, args.ycol, defaultcols))\\nif isHover and isColour:\\n    fig = px.scatter(df, x=args.xcol, y=args.ycol, color=args.colourcol, hover_name=args.hovercol)\\nelif isHover:\\n    fig = px.scatter(df, x=args.xcol, y=args.ycol, hover_name=args.hovercol)\\nelif isColour:\\n    fig = px.scatter(df, x=args.xcol, y=args.ycol, color=args.colourcol)\\nelse:\\n    fig = px.scatter(df, x=args.xcol, y=args.ycol)\\nif args.title:\\n    ftitle=dict(text=args.title, font=dict(size=50))\\n    fig.update_layout(title=ftitle)\\nfor scatter in fig.data:\\n    scatter['x'] = [str(x)[:MAXLEN] + '..' if len(str(x)) > MAXLEN else x for x in scatter['x']]\\n    scatter['y'] = [str(x)[:MAXLEN] + '..' if len(str(x)) > MAXLEN else x for x in scatter['y']]\\n    if len(args.colourcol.strip()) == 0:\\n        sl = str(scatter['legendgroup'])\\n        if len(sl) > MAXLEN:\\n            scatter['legendgroup'] = sl[:MAXLEN]\\nif args.image_type == \\\"short_html\\\":\\n    fig.write_html(args.htmlout, full_html=False, include_plotlyjs='cdn')\\nelif args.image_type == \\\"long_html\\\":\\n    fig.write_html(args.htmlout)\\nelif args.image_type == \\\"small_png\\\":\\n    ht = 768\\n    wdth = 1024\\n    fig.write_image('plotly.png', height=ht, width=wdth)\\n    shutil.copyfile('plotly.png', args.htmlout)\\nelse:\\n    ht = 1200\\n    wdth = 1920\\n    fig.write_image('plotly.png', height=ht, width=wdth)\\n    shutil.copyfile('plotly.png', args.htmlout)\\n\"}}, \"help_text\": \"This is a generic version of the plotlyblast specific blastn Galaxy search output file plotter.\\nPNG images are not interactive but best for very large numbers of data points. Hover column will be ignored.\\nHTML interactive plots are best for a few thousand data points at most because\\nthe hover information becomes uncontrollable with very dense points.\\nUsing the shorter format HTML relies on internet access when viewed, and saves 3MB of javascript being embedded.\\nThe long format is useful if potentially viewed offline.\\n\\n.. class:: warningmark\\nLong strings in x and y tickmarks WILL BE TRUNCATED if they are too long - \\\"..\\\" is added to indicate truncation - otherwise some plots are squished.\\n\\n.. class:: warningmark\\nColumns with very small scientific notation floats will need to be pre-scaled in a way that doesn't confuse plotly.express with their values.\\n\\n----\\n\\nThis tool can plot an interactive scatter plot with a hover text column specified, that appears when hovering over each data point, to supply useful additional information. \\nIt is only useful with a relatively small number of points when they can be distinguished. If many thousands, the density makes them relatively useless so use png output and\\nforget the hover text.\\n\\nColumn names are auto-generated as col1,...coln *unless* a comma separated list of column names is supplied as the header parameter, *or* pandas can \\nfind the values supplied as parameters by the user in the first row of data. This sounds more complex than it is.\\n\\nFor example, using a Galaxy blastn output with 25 columns, the following comma delimited string supplied as the \\\"header\\\" parameter will match the names of each column.\\n   qaccver,saccver,piden,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore,sallseqid,score,nident,positive,gaps,ppos,qframe,sframe,qseq,sseq,qlen,slen,salltitles\\n\\nWhen a header is supplied, the xcol and other column names must match one of those supplied column names.\\nSo for example, xcol = \\\"qaccver\\\" for the blastn header example rather than xcol = \\\"col1\\\" when no header is supplied.\\n\\nRelies on Plotly python code released under the MIT licence: https://github.com/plotly/plotly.py/blob/master/LICENSE.txt\\n\", \"io_param\": {\"ppass\": {\"parampass\": \"argparse\", \"__current_case__\": 0, \"io\": {\"history_inputs\": [{\"__index__\": 0, \"input_files\": {\"__class__\": \"ConnectedValue\"}, \"input_formats\": [\"tabular\"], \"input_label\": \"Tabular input file to plot\", \"input_help\": \"If 5000+ rows, html output will fail, but png will work.\", \"input_CL\": \"input_tab\", \"input_required\": \"required\"}], \"history_outputs\": [{\"__index__\": 0, \"history_name\": \"htmlout\", \"history_label\": \"Plotlytabular $title on $input_tab.element_identifier\", \"history_format\": \"html\", \"history_CL\": \"\", \"history_test\": \"sim_size:5000\", \"history_whens\": [{\"__index__\": 0, \"history_when\": \"when input=outputimagetype value=small_png format=png\"}, {\"__index__\": 1, \"history_when\": \"when input=outputimagetype value=large_png format=png\"}]}], \"collection_outputs\": []}, \"addparam\": {\"edit_params\": \"yes\", \"additional_parameters\": [{\"__index__\": 0, \"param_name\": \"xcol\", \"ap_type\": {\"param_type\": \"text\", \"__current_case__\": 0, \"param_value\": \"sepal_length\"}, \"param_label\": \"x axis for plot\", \"param_help\": \"Use a column name from the header if the file has one, or use one from the list supplied below, or use col1....colN otherwise to select the correct column\", \"param_CL\": \"xcol\", \"param_CLprefixed\": \"\", \"param_repeat\": false}, {\"__index__\": 1, \"param_name\": \"ycol\", \"ap_type\": {\"param_type\": \"text\", \"__current_case__\": 0, \"param_value\": \"sepal_width\"}, \"param_label\": \"y axis for plot\", \"param_help\": \"Use a column name from the header if the file has one, or use one from the list supplied below, or use col1....colN otherwise to select the correct column\", \"param_CL\": \"ycol\", \"param_CLprefixed\": \"\", \"param_repeat\": false}, {\"__index__\": 2, \"param_name\": \"colourcol\", \"ap_type\": {\"param_type\": \"text\", \"__current_case__\": 0, \"param_value\": \"petal_width\"}, \"param_label\": \"column containing a groupable variable for colour. Default none.\", \"param_help\": \"Adds a legend so choose wisely \", \"param_CL\": \"colourcol\", \"param_CLprefixed\": \"\", \"param_repeat\": false}, {\"__index__\": 3, \"param_name\": \"hovercol\", \"ap_type\": {\"param_type\": \"text\", \"__current_case__\": 0, \"param_value\": \"species\"}, \"param_label\": \"columname for hover string\", \"param_help\": \"Use a column name from the header if the file has one, or use one from the list supplied below, or use col1....colN otherwise to select the correct column\", \"param_CL\": \"hovercol\", \"param_CLprefixed\": \"\", \"param_repeat\": false}, {\"__index__\": 4, \"param_name\": \"title\", \"ap_type\": {\"param_type\": \"text\", \"__current_case__\": 0, \"param_value\": \"Iris data\"}, \"param_label\": \"Title for the plot\", \"param_help\": \"Special characters will probably be escaped so do not use them\", \"param_CL\": \"title\", \"param_CLprefixed\": \"\", \"param_repeat\": false}, {\"__index__\": 5, \"param_name\": \"header\", \"ap_type\": {\"param_type\": \"text\", \"__current_case__\": 0, \"param_value\": \"\"}, \"param_label\": \"Use this comma delimited list of column header names for this tabular file. Default is None when col1...coln will be used\", \"param_help\": \"The column names supplied for xcol, ycol, hover and colour MUST match either this supplied list, or if none, col1...coln.\", \"param_CL\": \"header\", \"param_CLprefixed\": \"\", \"param_repeat\": false}, {\"__index__\": 6, \"param_name\": \"outputimagetype\", \"ap_type\": {\"param_type\": \"selecttext\", \"__current_case__\": 4, \"selectTexts\": [{\"__index__\": 0, \"select_text\": \"Short HTML interactive format\", \"select_value\": \"short_html\"}, {\"__index__\": 1, \"select_text\": \"Long HTML for stand-alone viewing where network access to libraries is not available.\", \"select_value\": \"long_html\"}, {\"__index__\": 2, \"select_text\": \"Large (1920x1200) png image - not interactive so hover column ignored\", \"select_value\": \"large_png\"}, {\"__index__\": 3, \"select_text\": \"small (1024x768) png image - not interactive so hover column ignored\", \"select_value\": \"small_png\"}]}, \"param_label\": \"Select the output format for this plot image. If over 5000 rows of data, HTML breaks browsers, so your job will fail. Use png only if more than 5k rows.\", \"param_help\": \"Small and large png are not interactive but best for many (+10k) points. Stand-alone HTML includes 3MB of javascript. Short form HTML gets it the usual way so can be cut and paste into documents.\", \"param_CL\": \"image_type\", \"param_CLprefixed\": \"\", \"param_repeat\": false}]}}}, \"script_path\": \"\", \"tool_desc\": \"Plotly plot generator for Galaxy tabular data.\", \"tool_name\": \"plotlytabular\", \"tool_version\": \"3.0\", \"useremail\": \"\", \"__page__\": null, \"__rerun_remap_job_id__\": null}",
            "tool_version": "3.0",
            "type": "tool",
            "uuid": "0ce4e1ed-77d8-4363-a1f2-de05f0f3ca2a",
            "when": null,
            "workflow_outputs": []
        },
        "7": {
            "annotation": "",
            "content_id": "toolfactory",
            "errors": null,
            "id": 7,
            "input_connections": {
                "cl_options|xtracond|xtra_files": {
                    "id": 3,
                    "output_name": "output"
                },
                "io_param|ppass|io|history_inputs_0|input_files": {
                    "id": 3,
                    "output_name": "output"
                }
            },
            "inputs": [],
            "label": null,
            "name": "toolfactory",
            "outputs": [
                {
                    "name": "toolgen",
                    "type": "input"
                },
                {
                    "name": "untested_tool",
                    "type": "tgz"
                }
            ],
            "position": {
                "left": 280,
                "top": 378.9333190917969
            },
            "post_job_actions": {},
            "tool_id": "toolfactory",
            "tool_state": "{\"__input_ext\": \"input\", \"__workflow_invocation_uuid__\": \"2b5a9547917c11ee9703a7832fba00cb\", \"chromInfo\": \"/evol/galaxytf231/tool-data/shared/ucsc/chrom/?.len\", \"citations\": [], \"cl_options\": {\"cl_prefix\": \"\", \"cl_suffix\": \"\", \"cl_override\": \"bash $runme \\\"$blastn_search_outputs\\\" \\\"$__tool_directory__/BlastTools.jar\\\" \\\"$summary_viruses_viroids\\\" \\\"$all_blasttools_output\\\"\\n\", \"test_override\": \"\", \"xtracond\": {\"needxtra\": \"yes\", \"__current_case__\": 1, \"xtra_files\": {\"__class__\": \"ConnectedValue\"}}}, \"deps\": {\"packages\": \"csvtk=0.26.0, openjdk=11.0.13\", \"usescript\": {\"choosescript\": \"yes\", \"__current_case__\": 1, \"scriptrunner\": \"bash\", \"dynScript\": \"## eResearch Office, QUT\\n## Created:  31 March 2021\\n## Last modified: 28 September 2022\\n## Script: Processes Galaxy Australia generated blastN outputs to summarise and report hits to REGULATED and ENDEMIC viruses/viroids.\\n## Usage: ./run_VirReport_Summary.sh\\n## changed to accept a single input file name passed as $1\\n## Ross Lazarus for a ToolFactory wrapper for Robert Barrero\\n## July 18 2023\\n\\n\\n# Requirement: One or more GA-VSD .tabular outputs need to be in the folder where the command above (Usage)is executed.\\n# The script will Look for all files with the suffix *.tabular\\n\\n#Processing tabular files\\nfile=$1\\n    var=$(basename $file)\\n\\n    #STEP1: modify the columns of Galaxy Australia (GA) blast output to the expected format by the BlastTools.jar tool\\n    ######  namely: qseqid sgi sacc length pident mismatch gapopen qstart qend qlen sstart send slen sstrand evalue bitscore qcovhsp stitle staxids qseq sseq sseqid qcovs qframe sframe\\n    cat $file |csvtk cut -H -t -f 1,19,20,4,3,5,6,7,8,17,9,10,18,22,11,12,24,21,25,15,16,2,23,13,14 | sed 's/ /_/g' > ${var}_all.txt\\n    java -jar $2 -t blastn ${var}_all.txt\\n    cat summary_${var}_all.txt | grep \\\"virus\\\\|viroid\\\\|endo\\\" > $4\\n\\n\\n    #STEP0: fetch Top 1 Hits\\n    cat $file | awk '{print $1}' | sort | uniq > ${var}.top1.ids\\n    for i in `cat ${var}.top1.ids`\\n      do\\n        echo \\\"fetching top hits...\\\" $i 1>&2 ;\\n        grep $i $file | head -1 >> ${var}.top1Hits.txt;\\n      done\\n\\n    #STEP1: modify the columns of Galaxy Australia (GA) blast output to the expected format by the BlastTools.jar tool\\n    ######  namely: qseqid sgi sacc length pident mismatch gapopen qstart qend qlen sstart send slen sstrand evalue bitscore qcovhsp stitle staxids qseq sseq sseqid qcovs qframe sframe\\n    cat ${var}.top1Hits.txt |csvtk cut -H -t -f 1,19,20,4,3,5,6,7,8,17,9,10,18,22,11,12,24,21,25,15,16,2,23,13,14 | sed 's/ /_/g' > ${var}.txt\\n\\n    #STEP2: summarise the GA blastN files\\n    java -jar $2 -t blastn ${var}.txt\\n    #filter virus/viroid/endo\\n    cat summary_${var}.txt | grep \\\"virus\\\\|viroid\\\\|endo\\\" > summary_${var}_filtered.txt\\n\\n    #STEP3: fetch unique names from Blast summary reports\\n    cat summary_${var}_filtered.txt | awk '{print $7}' | awk -F \\\"|\\\" '{print $2}'| sort | uniq | sed 's/Species://' > ${var}_uniq.ids\\n\\n    #STEP4: retrieve the best hit for each virus/viroid\\n    echo \\\"processing top hits ...\\\" 1>&2\\n    touch ${var}_filtered.txt\\n    for id in `cat ${var}_uniq.ids`\\n      do\\n        #print on the screen the name of the virus/viroids to search\\n        #echo \\\"fetching species matches ...\\\" $id  1>&2\\n\\n        #fetch the virus name on the summary_blastn file by selecting the longest alignment (column 3) and highest genome coverage (column 5)\\n        grep $id summary_${var}.txt | sort -k3,3nr -k5,5nr | head -1 >> ${var}_filtered.txt\\n      done\\n\\n    #print the header of the inital summary_blastn file\\n    cat summary_${var}.txt | head -1 > header\\n    #report 1\\n    cat header ${var}_filtered.txt > $3\\n\\n\\n\\n\\n\\n\"}}, \"help_text\": \"**What it Does**\\nWraps https://github.com/schmidda/blast-tools/tree/master as a Galaxy tool as a demonstration for Roberto Barrero\", \"io_param\": {\"ppass\": {\"parampass\": \"positional\", \"__current_case__\": 3, \"io\": {\"history_inputs\": [{\"__index__\": 0, \"input_files\": {\"__class__\": \"ConnectedValue\"}, \"input_formats\": [\"tabular\"], \"input_label\": \"blastn_search_outputs\", \"input_help\": \"Nucleotide blast search output from a Galaxy blast search\", \"input_CL\": \"1\", \"input_required\": \"required\"}], \"history_outputs\": [{\"__index__\": 0, \"history_name\": \"summary_viruses_viroids\", \"history_label\": \"\", \"history_format\": \"tabular\", \"history_CL\": \"3\", \"history_test\": \"diff:0\", \"history_whens\": []}, {\"__index__\": 1, \"history_name\": \"all_blasttools_output\", \"history_label\": \"\", \"history_format\": \"tabular\", \"history_CL\": \"4\", \"history_test\": \"diff:0\", \"history_whens\": []}], \"collection_outputs\": []}, \"addparam\": {\"edit_params\": \"yes\", \"additional_parameters\": []}}}, \"script_path\": \"\", \"tool_desc\": \"Runs a legacy Java jar called blasttools from https://github.com/schmidda/blast-tools/tree/master\", \"tool_name\": \"blast_tools_search\", \"tool_version\": \"3.0\", \"useremail\": \"\", \"__page__\": null, \"__rerun_remap_job_id__\": null}",
            "tool_version": "3.0",
            "type": "tool",
            "uuid": "bd46e433-4d2f-44b0-a38a-75597f1bf5f9",
            "when": null,
            "workflow_outputs": []
        },
        "8": {
            "annotation": "",
            "content_id": "toolfactory",
            "errors": null,
            "id": 8,
            "input_connections": {
                "io_param|ppass|io|history_inputs_0|input_files": {
                    "id": 4,
                    "output_name": "output"
                }
            },
            "inputs": [],
            "label": null,
            "name": "toolfactory",
            "outputs": [
                {
                    "name": "toolgen",
                    "type": "input"
                },
                {
                    "name": "untested_tool",
                    "type": "tgz"
                }
            ],
            "position": {
                "left": 840,
                "top": 0
            },
            "post_job_actions": {},
            "tool_id": "toolfactory",
            "tool_state": "{\"__input_ext\": \"input\", \"__workflow_invocation_uuid__\": \"2b5a9547917c11ee9703a7832fba00cb\", \"chromInfo\": \"/evol/galaxytf231/tool-data/shared/ucsc/chrom/?.len\", \"citations\": [], \"cl_options\": {\"cl_prefix\": \"\", \"cl_suffix\": \"\", \"cl_override\": \"\", \"test_override\": \"\", \"xtracond\": {\"needxtra\": \"no\", \"__current_case__\": 0, \"xtra_files\": \"\"}}, \"deps\": {\"packages\": \"pandas=1.5.3, matplotlib=3.7.2, lifelines=0.27.7\", \"usescript\": {\"choosescript\": \"yes\", \"__current_case__\": 1, \"scriptrunner\": \"python\", \"dynScript\": \"# script for a lifelines ToolFactory KM/CPH tool for Galaxy\\n# km models for https://github.com/galaxyproject/tools-iuc/issues/5393\\n# test as\\n# python plotlykm.py --input_tab rossi.tab --htmlout \\\"testfoo\\\" --time \\\"week\\\" --status \\\"arrest\\\" --title \\\"test\\\" --image_dir images --cphcol=\\\"prio,age,race,paro,mar,fin\\\"\\n\\nimport argparse\\nimport os\\nimport sys\\n\\nimport lifelines\\n\\nfrom matplotlib import pyplot as plt\\n\\nimport pandas as pd\\n\\n# Ross Lazarus July 2023\\n\\n\\nkmf = lifelines.KaplanMeierFitter()\\ncph = lifelines.CoxPHFitter()\\n\\nparser = argparse.ArgumentParser()\\na = parser.add_argument\\na('--input_tab', default='', required=True)\\na('--header', default='')\\na('--htmlout', default=\\\"test_run.html\\\")\\na('--group', default='')\\na('--time', default='', required=True)\\na('--status',default='', required=True)\\na('--cphcols',default='')\\na('--title', default='Default plot title')\\na('--image_type', default='png')\\na('--image_dir', default='images')\\na('--readme', default='run_log.txt')\\nargs = parser.parse_args()\\nsys.stdout = open(args.readme, 'w')\\ndf = pd.read_csv(args.input_tab, sep='\\\\t')\\nNCOLS = df.columns.size\\nNROWS = len(df.index)\\ndefaultcols = ['col%d' % (x+1) for x in range(NCOLS)]\\ntestcols = df.columns\\nif len(args.header.strip()) > 0:\\n    newcols = args.header.split(',')\\n    if len(newcols) == NCOLS:\\n        if (args.time in newcols) and (args.status in newcols):\\n            df.columns = newcols\\n        else:\\n            sys.stderr.write('## CRITICAL USAGE ERROR (not a bug!): time %s and/or status %s not found in supplied header parameter %s' % (args.time, args.status, args.header))\\n            sys.exit(4)\\n    else:\\n        sys.stderr.write('## CRITICAL USAGE ERROR (not a bug!): Supplied header %s has %d comma delimited header names - does not match the input tabular file %d columns' % (args.header, len(newcols), NCOLS))\\n        sys.exit(5)\\nelse: # no header supplied - check for a real one that matches the x and y axis column names\\n    colsok = (args.time in testcols) and (args.status in testcols) # if they match, probably ok...should use more code and logic..\\n    if colsok:\\n        df.columns = testcols # use actual header\\n    else:\\n        colsok = (args.time in defaultcols) and (args.status in defaultcols)\\n        if colsok:\\n            sys.stderr.write('replacing first row of data derived header %s with %s' % (testcols, defaultcols))\\n            df.columns = defaultcols\\n        else:\\n            sys.stderr.write('## CRITICAL USAGE ERROR (not a bug!): time %s and status %s do not match anything in the file header, supplied header or automatic default column names %s' % (args.time, args.status, defaultcols))\\nprint('## Lifelines tool starting.\\\\nUsing data header =', df.columns, 'time column =', args.time, 'status column =', args.status)\\nos.makedirs(args.image_dir, exist_ok=True)\\nfig, ax = plt.subplots()\\nif args.group > '':\\n    names = []\\n    times = []\\n    events = []\\n    rmst = []\\n    for name, grouped_df in df.groupby(args.group):\\n        T = grouped_df[args.time]\\n        E = grouped_df[args.status]\\n        gfit = kmf.fit(T, E, label=name)\\n        kmf.plot_survival_function(ax=ax)\\n        rst = lifelines.utils.restricted_mean_survival_time(gfit)\\n        rmst.append(rst)\\n        names.append(str(name))\\n        times.append(T)\\n        events.append(E)    \\n    ax.set_title(args.title)\\n    fig.savefig(os.path.join(args.image_dir,'KM_%s.png' % args.title))\\n    ngroup = len(names)\\n    if  ngroup == 2: # run logrank test if 2 groups\\n        results = lifelines.statistics.logrank_test(times[0], times[1], events[0], events[1], alpha=.99)\\n        print('Logrank test for %s - %s vs %s\\\\n' % (args.group, names[0], names[1]))\\n        results.print_summary()\\n    elif ngroup > 1:\\n        fig, ax = plt.subplots(nrows=ngroup, ncols=1, sharex=True)\\n        for i, rst in rmst:\\n            lifelines.plotting.rmst_plot(rst, ax=ax)\\n        fig.savefig(os.path.join(args.image_dir,'RMST_%s.png' % args.title))\\nelse:\\n    kmf.fit(df[args.time], df[args.status])\\n    kmf.plot_survival_function(ax=ax)\\n    ax.set_title(args.title)\\n    fig.savefig(os.path.join(args.image_dir,'KM_%s.png' % args.title))\\nif len(args.cphcols) > 0:\\n    fig, ax = plt.subplots()\\n    ax.set_title('Cox PH model: %s' % args.title)\\n    cphcols = args.cphcols.strip().split(',')\\n    cphcols = [x.strip() for x in cphcols]\\n    notfound = sum([(x not in df.columns) for x in cphcols])\\n    if notfound > 0:\\n        sys.stderr.write('## CRITICAL USAGE ERROR (not a bug!): One or more requested Cox PH columns %s not found in supplied column header %s' % (args.cphcols, df.columns))\\n        sys.exit(6)\\n    print('### Lifelines test of Proportional Hazards results with %s as covariates on %s' % (', '.join(cphcols), args.title))\\n    cphcols += [args.time, args.status]\\n    cphdf = df[cphcols]\\n    cph.fit(cphdf, duration_col=args.time, event_col=args.status)\\n    cph.print_summary()\\n    cphaxes = cph.check_assumptions(cphdf, p_value_threshold=0.01, show_plots=True)\\n    for i, ax in enumerate(cphaxes):\\n        figr = ax[0].get_figure()\\n        titl = figr._suptitle.get_text().replace(' ','_').replace(\\\"'\\\",\\\"\\\")\\n        oname = os.path.join(args.image_dir,'CPH%s.%s' % (titl, args.image_type))\\n        figr.savefig(oname)\\n\"}}, \"help_text\": \"This is a wrapper for some elementary life table analysis functions from the Lifelines package - see https://lifelines.readthedocs.io/en/latest for the full story\\n\\nGiven a Galaxy tabular dataset with suitable indicators for time and status at observation, this tool can perform some simple life-table analyses and produce some useful plots. Kaplan-Meier is the default. Cox Proportional Hazards model will be tested if covariates to include are provided.\\n\\n1. Kaplan-Meier survival analysis - see https://lifelines.readthedocs.io/en/latest/Survival%20analysis%20with%20lifelines.html\\n    This is always performed and a survival curve is plotted. \\n    If there is an optional \\\"group\\\" column, the plot will show each group separately. If there are *exactly* two groups, a log-rank test for difference is performed and reported\\n\\n2. The Cox Proportional Hazards model can be tested, if a comma separated list of covariate column names is supplied on the tool form.\\n    These are used in as covariates. \\n    Although not usually a real problem, some diagnostics and advice about the assumption of proportional hazards are are also provided as outputs - see   https://lifelines.readthedocs.io/en/latest/Survival%20Regression.html\\n\\nA big shout out to the lifelines authors - no R code needed - nice job, thanks!\", \"io_param\": {\"ppass\": {\"parampass\": \"argparse\", \"__current_case__\": 0, \"io\": {\"history_inputs\": [{\"__index__\": 0, \"input_files\": {\"__class__\": \"ConnectedValue\"}, \"input_formats\": [\"tabular\"], \"input_label\": \"Tabular input file for failure time testing.\", \"input_help\": \"Must have a column with a measure of time and status (0,1) at observation.\", \"input_CL\": \"input_tab\", \"input_required\": \"required\"}], \"history_outputs\": [{\"__index__\": 0, \"history_name\": \"readme\", \"history_label\": \"Lifelines_km_cph $title on $input_tab.element_identifier\", \"history_format\": \"txt\", \"history_CL\": \"\", \"history_test\": \"sim_size:1000\", \"history_whens\": []}], \"collection_outputs\": [{\"__index__\": 0, \"name\": \"image_dir\", \"kind\": \"list\", \"label\": \"Images from $title on $input_tab.element_identifier\", \"discover\": \"__name_and_ext__\"}]}, \"addparam\": {\"edit_params\": \"yes\", \"additional_parameters\": [{\"__index__\": 0, \"param_name\": \"time\", \"ap_type\": {\"param_type\": \"text\", \"__current_case__\": 0, \"param_value\": \"week\"}, \"param_label\": \"Name of column containing a time to observation\", \"param_help\": \"Use a column name from the file header if the data has one, or use one from the list supplied below, or use col1....colN otherwise to select the correct column\", \"param_CL\": \"time\", \"param_CLprefixed\": \"\", \"param_repeat\": false}, {\"__index__\": 1, \"param_name\": \"status\", \"ap_type\": {\"param_type\": \"text\", \"__current_case__\": 0, \"param_value\": \"arrest\"}, \"param_label\": \"Status at observation. Typically 1=alive, 0=deceased for life-table observations\", \"param_help\": \"Use a column name from the header if the file has one, or use one from the list supplied below, or use col1....colN otherwise to select the correct column\", \"param_CL\": \"status\", \"param_CLprefixed\": \"\", \"param_repeat\": false}, {\"__index__\": 2, \"param_name\": \"CPH covariate column names\", \"ap_type\": {\"param_type\": \"text\", \"__current_case__\": 0, \"param_value\": \"prio,age,race,paro,mar,fin\"}, \"param_label\": \"Optional comma delimited column names to use as covariates in the Cox Proportional Hazards model\", \"param_help\": \"Leave blank for no Cox PH model tests \", \"param_CL\": \"cphcols\", \"param_CLprefixed\": \"\", \"param_repeat\": false}, {\"__index__\": 3, \"param_name\": \"image_type\", \"ap_type\": {\"param_type\": \"selecttext\", \"__current_case__\": 4, \"selectTexts\": [{\"__index__\": 0, \"select_text\": \"Portable Network Graphics .png format\", \"select_value\": \"png\"}, {\"__index__\": 1, \"select_text\": \"JPEG\", \"select_value\": \"jpg\"}, {\"__index__\": 2, \"select_text\": \"PDF\", \"select_value\": \"pdf\"}, {\"__index__\": 3, \"select_text\": \"TIFF\", \"select_value\": \"tiff\"}]}, \"param_label\": \"Output format for all images\", \"param_help\": \"\", \"param_CL\": \"image_type\", \"param_CLprefixed\": \"\", \"param_repeat\": false}, {\"__index__\": 4, \"param_name\": \"title\", \"ap_type\": {\"param_type\": \"text\", \"__current_case__\": 0, \"param_value\": \"KM and CPH in lifelines test \"}, \"param_label\": \"Title for this lifelines analysis\", \"param_help\": \"Special characters will probably be escaped so do not use them\", \"param_CL\": \"title\", \"param_CLprefixed\": \"\", \"param_repeat\": false}, {\"__index__\": 5, \"param_name\": \"header\", \"ap_type\": {\"param_type\": \"text\", \"__current_case__\": 0, \"param_value\": \"\"}, \"param_label\": \"Optional comma delimited list of column names to use for this tabular file. Default is None when col1...coln will be used if no header row in the input data\", \"param_help\": \"The column names supplied for time, status and so on MUST match either this supplied list, or if none, the original file header if it exists, or col1...coln as the default of last resort.\", \"param_CL\": \"header\", \"param_CLprefixed\": \"\", \"param_repeat\": false}, {\"__index__\": 6, \"param_name\": \"group\", \"ap_type\": {\"param_type\": \"text\", \"__current_case__\": 0, \"param_value\": \"race\"}, \"param_label\": \"Optional group column name for KM plot\", \"param_help\": \"If there are exactly 2 groups, a log-rank statistic will be generated as part of the Kaplan-Meier test.\", \"param_CL\": \"group\", \"param_CLprefixed\": \"\", \"param_repeat\": false}]}}}, \"script_path\": \"\", \"tool_desc\": \"Lifelines KM and optional Cox PH models\", \"tool_name\": \"lifelines_km_cph\", \"tool_version\": \"0.01\", \"useremail\": \"\", \"__page__\": null, \"__rerun_remap_job_id__\": null}",
            "tool_version": "3.0",
            "type": "tool",
            "uuid": "ad0d69c4-b3c6-40ec-8730-65a88c129e59",
            "when": null,
            "workflow_outputs": []
        },
        "9": {
            "annotation": "",
            "content_id": "toolfactory",
            "errors": null,
            "id": 9,
            "input_connections": {
                "io_param|ppass|io|history_inputs_0|input_files": {
                    "id": 5,
                    "output_name": "output"
                }
            },
            "inputs": [],
            "label": null,
            "name": "toolfactory",
            "outputs": [
                {
                    "name": "toolgen",
                    "type": "input"
                },
                {
                    "name": "untested_tool",
                    "type": "tgz"
                }
            ],
            "position": {
                "left": 840,
                "top": 194.46665954589844
            },
            "post_job_actions": {},
            "tool_id": "toolfactory",
            "tool_state": "{\"__input_ext\": \"input\", \"chromInfo\": \"/evol/galaxytf231/tool-data/shared/ucsc/chrom/?.len\", \"citations\": [], \"cl_options\": {\"cl_prefix\": \"\", \"cl_suffix\": \"\", \"cl_override\": \"\", \"test_override\": \"\", \"xtracond\": {\"needxtra\": \"no\", \"__current_case__\": 0, \"xtra_files\": \"\"}}, \"deps\": {\"packages\": \"pandas=1.5.3, plotly=5.9.0, python-kaleido=0.2.1\", \"usescript\": {\"choosescript\": \"yes\", \"__current_case__\": 1, \"scriptrunner\": \"python\", \"dynScript\": \"import argparse\\nimport shutil\\nimport sys\\nimport math\\nimport plotly.express as px\\nimport pandas as pd\\n# Ross Lazarus July 2023\\n# based on various plotly tutorials\\n# Expects a blastn search result passed in as the first command line parameter.\\nparser = argparse.ArgumentParser()\\na = parser.add_argument\\na('--input_tab',default='')\\na('--header',default='qaccver,saccver,piden,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore,sallseqid,score,nident,positive,gaps,ppos,qframe,sframe,qseq,sseq,qlen,slen,salltitles')\\na('--htmlout',default=\\\"test_run.html\\\")\\na('--xcol',default='')\\na('--ycol',default='')\\na('--colourcol',default='')\\na('--hovercol',default='')\\na('--title',default='test blast plot')\\na('--image_type',default='short_html')\\nargs = parser.parse_args()\\nisColour = False\\nisHover = False\\nif len(args.colourcol.strip()) > 0:\\n    isColour = True\\nif len(args.hovercol.strip()) > 0:\\n    isHover = True\\ndf = pd.read_csv(args.input_tab, sep='\\\\t')\\nMAXHTMLROWS = 5000\\nMAXLEN=30 # short labels\\nNCOLS = df.columns.size\\nNROWS = len(df.index)\\ndefaultcols = ['col%d' % (x+1) for x in range(NCOLS)]\\ntestcols = df.columns\\nif args.image_type in ['short_html', 'long_html']: # refuse to create browser crashing gob stopper html\\n    if NROWS > MAXHTMLROWS:\\n        sys.stderr.write('## CRITICAL USAGE ERROR (not a bug!): As advised on the tool form, 5k+ rows (you supplied %d) in html breaks browsers, so redo the job but change to png format output.' % NROWS)\\n        sys.exit(6)\\nif len(args.header.strip()) > 0:\\n    newcols = args.header.split(',')\\n    if len(newcols) == NCOLS:\\n        if (args.xcol in newcols) and (args.ycol in newcols):\\n            df.columns = newcols\\n        else:\\n            sys.stderr.write('## CRITICAL USAGE ERROR (not a bug!): xcol %s and/or ycol %s not found in supplied header parameter %s' % (args.xcol, args.ycol, args.header))\\n            sys.exit(4)\\n    else:\\n        sys.stderr.write('## CRITICAL USAGE ERROR (not a bug!): Supplied header %s has %d comma delimited header names - does not match the input tabular file %d columns' % (args.header, len(newcols), NCOLS))\\n        sys.exit(5)\\nelse: # no header supplied - check for a real one that matches the x and y axis column names\\n    colsok = (args.xcol in testcols) and (args.ycol in testcols) # if they match, probably ok...should use more code and logic..\\n    if colsok:\\n        df.columns = testcols # use actual header\\n    else:\\n        colsok = (args.xcol in defaultcols) and (args.ycol in defaultcols)\\n        if colsok:\\n            sys.stderr.write('replacing first row of data derived header %s with %s' % (testcols, defaultcols))\\n            df.columns = defaultcols\\n        else:\\n            sys.stderr.write('## CRITICAL USAGE ERROR (not a bug!): xcol %s and ycol %s do not match anything in the file header, supplied header or automatic default column names %s' % (args.xcol, args.ycol, defaultcols))\\ndf['evalue'] = [-math.log(x + 1e-308) for x in df['evalue']] # convert so large values reflect statistical surprise\\nif isHover and isColour:\\n    fig = px.scatter(df, x=args.xcol, y=args.ycol, color=args.colourcol, hover_name=args.hovercol)\\nelif isHover:\\n    fig = px.scatter(df, x=args.xcol, y=args.ycol, hover_name=args.hovercol)\\nelif isColour:\\n    fig = px.scatter(df, x=args.xcol, y=args.ycol, color=args.colourcol)\\nelse:\\n    fig = px.scatter(df, x=args.xcol, y=args.ycol)\\nif args.title:\\n    ftitle=dict(text=args.title, font=dict(size=40))\\n    fig.update_layout(title=ftitle)\\nfor scatter in fig.data:\\n    scatter['x'] = [str(x)[:MAXLEN] + '..' if len(str(x)) > MAXLEN else x for x in scatter['x']]\\n    scatter['y'] = [str(x)[:MAXLEN] + '..' if len(str(x)) > MAXLEN else x for x in scatter['y']]\\n    if len(args.colourcol.strip()) == 0:\\n        sl = str(scatter['legendgroup'])\\n        if len(sl) > MAXLEN:\\n            scatter['legendgroup'] = sl[:MAXLEN]\\nif args.image_type == \\\"short_html\\\":\\n    fig.write_html(args.htmlout, full_html=False, include_plotlyjs='cdn')\\nelif args.image_type == \\\"long_html\\\":\\n    fig.write_html(args.htmlout)\\nelif args.image_type == \\\"small_png\\\":\\n    ht = 768\\n    wdth = 1024\\n    fig.write_image('plotly.png', height=ht, width=wdth)\\n    shutil.copyfile('plotly.png', args.htmlout)\\nelse:\\n    ht = 1200\\n    wdth = 1920\\n    fig.write_image('plotly.png', height=ht, width=wdth)\\n    shutil.copyfile('plotly.png', args.htmlout)\\n\\n\"}}, \"help_text\": \"This is a specialised version of a generic tabular file plotter tool plotlytabular\\nPNG image outputs are not interactive but best for very large numbers of data points. Hover column will be ignored.\\nHTML interactive plots are best for a few thousand data points at most because\\nthe hover information becomes uncontrollable with very dense points.\\nUsing the shorter format HTML relies on internet access when viewed, and saves 3MB of javascript being embedded.\\nThe long format is useful if potentially viewed offline.\\n\\n.. class:: warningmark\\nNOTE: Long strings in x and y tickmarks WILL BE TRUNCATED if they are too long - \\\"..\\\" is added to indicate truncation - otherwise some plots are squished.\\n\\n.. class:: warningmark\\nNOTE: Blast evalues WILL BE TRANSFORMED using -log10(evalue), so they are scaled in a way that doesn't confuse plotly.express with the tiny values.\\n\\n----\\n\\nThe main reason to run this tool is to have an interactive hover text specified so it appears when hovering over each data point to supply useful information. \\n\\nAssumes you want a hover display for an interactive plot to be informative\\n\\nColumn names are auto-generated as col1,...coln unless a comma separated list of column names is supplied as the header parameter.\\n\\nFor example, using a Galaxy blastn output with 25 columns, the following comma delimited string supplied as the \\\"header\\\" parameter will match the names of each column.\\n   qaccver,saccver,piden,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore,sallseqid,score,nident,positive,gaps,ppos,qframe,sframe,qseq,sseq,qlen,slen,salltitles\\n\\nWhen a header is supplied, the xcol and other column names must match one of those supplied column names.\\nSo for example, xcol = \\\"qaccver\\\" for the blastn header example rather than xcol = \\\"col1\\\" when no header is supplied.\\n\\nRelies on Plotly python code released under the MIT licence: https://github.com/plotly/plotly.py/blob/master/LICENSE.txt\\n\\n\", \"io_param\": {\"ppass\": {\"parampass\": \"argparse\", \"__current_case__\": 0, \"io\": {\"history_inputs\": [{\"__index__\": 0, \"input_files\": {\"__class__\": \"ConnectedValue\"}, \"input_formats\": [\"tabular\"], \"input_label\": \"Tabular input file to plot\", \"input_help\": \"\", \"input_CL\": \"input_tab\", \"input_required\": \"required\"}], \"history_outputs\": [{\"__index__\": 0, \"history_name\": \"htmlout\", \"history_label\": \"Plotlyblast $title on $input_tab.element_identifier\", \"history_format\": \"html\", \"history_CL\": \"\", \"history_test\": \"sim_size:5000\", \"history_whens\": [{\"__index__\": 0, \"history_when\": \"when input=outputimagetype value=small_png format=png\"}, {\"__index__\": 1, \"history_when\": \"when input=outputimagetype value=large_png format=png\"}]}], \"collection_outputs\": []}, \"addparam\": {\"edit_params\": \"yes\", \"additional_parameters\": [{\"__index__\": 0, \"param_name\": \"xcol\", \"ap_type\": {\"param_type\": \"text\", \"__current_case__\": 0, \"param_value\": \"qaccver\"}, \"param_label\": \"x axis for plot\", \"param_help\": \"\", \"param_CL\": \"xcol\", \"param_CLprefixed\": \"\", \"param_repeat\": false}, {\"__index__\": 1, \"param_name\": \"ycol\", \"ap_type\": {\"param_type\": \"text\", \"__current_case__\": 0, \"param_value\": \"bitscore\"}, \"param_label\": \"y axis for plot\", \"param_help\": \"\", \"param_CL\": \"ycol\", \"param_CLprefixed\": \"\", \"param_repeat\": false}, {\"__index__\": 2, \"param_name\": \"colourcol\", \"ap_type\": {\"param_type\": \"text\", \"__current_case__\": 0, \"param_value\": \"piden\"}, \"param_label\": \"column containing a groupable variable for colour. Default none.\", \"param_help\": \"Adds a legend so choose wisely \", \"param_CL\": \"colourcol\", \"param_CLprefixed\": \"\", \"param_repeat\": false}, {\"__index__\": 3, \"param_name\": \"hovercol\", \"ap_type\": {\"param_type\": \"text\", \"__current_case__\": 0, \"param_value\": \"qseq\"}, \"param_label\": \"columname for hover string\", \"param_help\": \"\", \"param_CL\": \"hovercol\", \"param_CLprefixed\": \"\", \"param_repeat\": false}, {\"__index__\": 4, \"param_name\": \"title\", \"ap_type\": {\"param_type\": \"text\", \"__current_case__\": 0, \"param_value\": \"Qaccver by bitscore coloured by pident. Hover shows blast match.\"}, \"param_label\": \"Title for the plot\", \"param_help\": \"Special characters will probably be escaped so do not use them\", \"param_CL\": \"title\", \"param_CLprefixed\": \"\", \"param_repeat\": false}, {\"__index__\": 5, \"param_name\": \"header\", \"ap_type\": {\"param_type\": \"text\", \"__current_case__\": 0, \"param_value\": \"qaccver,saccver,piden,length,mismatch,gapopen,qstart,qend,sstart,send,evalue,bitscore,sallseqid,score,nident,positive,gaps,ppos,qframe,sframe,qseq,sseq,qlen,slen,salltitles\"}, \"param_label\": \"Use this comma delimited list of column header names for this tabular file. Default is None when col1...coln will be used\", \"param_help\": \"Default for Galaxy blast outputs with 25 columns. The column names supplied for xcol, ycol, hover and colour MUST match either the supplied list, or if none, col1...coln.\", \"param_CL\": \"header\", \"param_CLprefixed\": \"\", \"param_repeat\": false}, {\"__index__\": 6, \"param_name\": \"outputimagetype\", \"ap_type\": {\"param_type\": \"selecttext\", \"__current_case__\": 4, \"selectTexts\": [{\"__index__\": 0, \"select_text\": \"Short HTML interactive - requires network connection to download 3MB javascript\", \"select_value\": \"short_html\"}, {\"__index__\": 1, \"select_text\": \"Long HTML for stand-alone viewing where network access to libraries is not available.\", \"select_value\": \"long_html\"}, {\"__index__\": 2, \"select_text\": \"Large (1920x1200) png image - not interactive so hover column ignored\", \"select_value\": \"large_png\"}, {\"__index__\": 3, \"select_text\": \"Small (1024x768) png image - not interactive so hover column ignored\", \"select_value\": \"small_png\"}]}, \"param_label\": \"Select the output format for this plot image\", \"param_help\": \"Small and large png are not interactive but best for many (>10k) points. Stand-alone HTML includes 3MB of javascript. Short form HTML gets it the usual way so can be cut and paste into documents.\", \"param_CL\": \"image_type\", \"param_CLprefixed\": \"\", \"param_repeat\": false}]}}}, \"script_path\": \"\", \"tool_desc\": \"Plotly plot generator specialised for 25 column Galaxy blast search result tabular files\", \"tool_name\": \"plotly_blast\", \"tool_version\": \"3.0\", \"useremail\": \"\", \"__page__\": null, \"__rerun_remap_job_id__\": null}",
            "tool_version": "3.0",
            "type": "tool",
            "uuid": "c7a83213-b2d2-44f2-bf2f-03f0887602f2",
            "when": null,
            "workflow_outputs": []
        }
    },
    "tags": [],
    "uuid": "19e2cc82-ff1d-4bff-8442-316b1d307354",
    "version": 1
}